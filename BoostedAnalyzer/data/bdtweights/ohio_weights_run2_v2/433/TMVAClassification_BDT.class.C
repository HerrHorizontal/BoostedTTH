// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.0         [262656]
ROOT Release   : 5.34/18       [336402]
Creator        : flowers1
Date           : Tue Jun 30 15:25:23 2015
Host           : Linux cmsdev02.cern.ch 2.6.32-431.23.3.el6.x86_64 #1 SMP Wed Jul 30 09:43:11 CEST 2014 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /uscms_data/d3/flowers1/May2015/CMSSW_7_2_3/src/ttH-LeptonPlusJets/AnalysisCode/macros/TRAINHOUSE
Training events: 918
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "Grad" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
Shrinkage: "1.000000e-01" [Learning rate for GradBoost algorithm]
NegWeightTreatment: "ignorenegweightsintraining" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
NNodesMax: "5" [deprecated: Use MaxDepth instead to limit the tree size]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
MaxDepth: "2" [Max depth of the decision tree allowed]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "3" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
SeparationType: "giniindex" [Separation criterion for node splitting]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 10
first_jet_pt                  first_jet_pt                  first_jet_pt                  first_jet_pt                  first_jet_pt                      'F'    [41.6685447693,688.196105957]
second_jet_pt                 second_jet_pt                 second_jet_pt                 second_jet_pt                 second_jet_pt                     'F'    [31.7360591888,632.600158691]
third_jet_pt                  third_jet_pt                  third_jet_pt                  third_jet_pt                  third_jet_pt                      'F'    [30.8605365753,267.013885498]
all_sum_pt_with_met           all_sum_pt_with_met           all_sum_pt_with_met           all_sum_pt_with_met           all_sum_pt_with_met               'F'    [207.966171265,1505.08837891]
HT                            HT                            HT                            HT                            HT                                'F'    [135.690322876,1424.64648438]
avg_btag_disc_btags           avg_btag_disc_btags           avg_btag_disc_btags           avg_btag_disc_btags           avg_btag_disc_btags               'F'    [0.835238397121,0.998479902744]
dev_from_avg_disc_btags       dev_from_avg_disc_btags       dev_from_avg_disc_btags       dev_from_avg_disc_btags       dev_from_avg_disc_btags           'F'    [4.09820515301e-08,0.00727716088295]
second_highest_btag           second_highest_btag           second_highest_btag           second_highest_btag           second_highest_btag               'F'    [0.83031386137,0.999704539776]
third_highest_btag            third_highest_btag            third_highest_btag            third_highest_btag            third_highest_btag                'F'    [0.814223885536,0.997355759144]
invariant_mass_of_everything  invariant_mass_of_everything  invariant_mass_of_everything  invariant_mass_of_everything  invariant_mass_of_everything      'F'    [297.93270874,2536.59204102]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 10 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "first_jet_pt", "second_jet_pt", "third_jet_pt", "all_sum_pt_with_met", "HT", "avg_btag_disc_btags", "dev_from_avg_disc_btags", "second_highest_btag", "third_highest_btag", "invariant_mass_of_everything" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[10];
   double fVmax[10];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[10];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += current->GetResponse();
   }
   return 2.0/(1.0+exp(-2.0*myMVA))-1.0;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.331959,-0.0336082) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.625,0.025) , 
2, 68.6853, 1, 0, 0.422254,-0.0777461) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.69375,0.03875) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.912281,0.0824561) , 
5, 0.988128, 1, 0, 0.751152,0.251152) , 
5, 0.967386, 1, 0, 0.5,0)    );
  // itree = 1
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.304569,-0.0361975) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.57329,0.0144606) , 
3, 455.037, 1, 0, 0.422254,-0.069975) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.69375,0.0349293) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.912281,0.074735) , 
5, 0.988128, 1, 0, 0.751152,0.226068) , 
5, 0.967386, 1, 0, 0.5,4.74399e-06)    );
  // itree = 2
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.331959,-0.0279945) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.625,0.0217655) , 
2, 68.6853, 1, 0, 0.422254,-0.0629924) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.69375,0.0315661) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.912281,0.0685311) , 
5, 0.988128, 1, 0, 0.751152,0.203562) , 
5, 0.967386, 1, 0, 0.5,1.65711e-05)    );
  // itree = 3
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.304348,-0.0306435) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.570968,0.0127186) , 
4, 319.827, 1, 0, 0.422254,-0.0567082) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.69375,0.0285784) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.912281,0.0633824) , 
5, 0.988128, 1, 0, 0.751152,0.183342) , 
5, 0.967386, 1, 0, 0.5,3.58036e-05)    );
  // itree = 4
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.30102,-0.0292691) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.71134,0.0282067) , 
8, 0.936228, 1, 0, 0.382413,-0.0886375) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.502959,-0.00179003) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.719231,0.03513) , 
8, 0.875268, 1, 0, 0.634033,0.101141) , 
3, 455.037, 1, 0, 0.5,4.9873e-05)    );
  // itree = 5
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.308642,-0.0257028) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.738095,0.0297716) , 
8, 0.944903, 1, 0, 0.382413,-0.079802) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.502959,-0.00161089) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.719231,0.0318713) , 
8, 0.875268, 1, 0, 0.634033,0.0910647) , 
3, 455.037, 1, 0, 0.5,4.74428e-05)    );
  // itree = 6
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.331959,-0.0203599) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.625,0.0170088) , 
2, 68.6853, 1, 0, 0.422254,-0.0428018) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.672269,0.0167896) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.846939,0.045361) , 
5, 0.982213, 1, 0, 0.751152,0.138477) , 
5, 0.967386, 1, 0, 0.5,4.94935e-05)    );
  // itree = 7
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.30102,-0.0226576) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.71134,0.0213291) , 
8, 0.936228, 1, 0, 0.382413,-0.0678682) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.502959,-0.00162694) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.719231,0.0277634) , 
8, 0.875268, 1, 0, 0.634033,0.077498) , 
3, 455.037, 1, 0, 0.5,6.43215e-05)    );
  // itree = 8
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.331019,-0.0186191) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.847826,0.0416603) , 
8, 0.962309, 1, 0, 0.380753,-0.0627151) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.526549,0.00162078) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.738318,0.0280727) , 
5, 0.94765, 1, 0, 0.629545,0.0682602) , 
4, 319.827, 1, 0, 0.5,6.17422e-05)    );
  // itree = 9
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.30102,-0.0191502) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.71134,0.0182997) , 
8, 0.936228, 1, 0, 0.382413,-0.0563209) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.502959,-0.00146237) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.719231,0.0235916) , 
8, 0.875268, 1, 0, 0.634033,0.0643566) , 
3, 455.037, 1, 0, 0.5,7.41011e-05)    );
  // itree = 10
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.307479,-0.0199319) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.763889,0.0259955) , 
8, 0.944903, 1, 0, 0.383372,-0.059283) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.631737,0.0188404) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.543046,-0.00563411) , 
9, 891.866, 1, 0, 0.604124,0.0530602) , 
9, 617.741, 1, 0, 0.5,7.0476e-05)    );
  // itree = 11
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.331019,-0.0149986) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.847826,0.0356686) , 
8, 0.962309, 1, 0, 0.380753,-0.0491984) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.492958,-0.0040382) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.694631,0.0190185) , 
5, 0.933128, 1, 0, 0.629545,0.0535747) , 
4, 319.827, 1, 0, 0.5,6.1062e-05)    );
  // itree = 12
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.27,-0.0273461) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.542636,0.00676376) , 
9, 699.193, 1, 0, 0.3769,-0.064844) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.341772,-0.0231147) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.603922,0.0126674) , 
3, 328.566, 1, 0, 0.568761,0.0363248) , 
7, 0.943241, 1, 0, 0.5,6.71614e-05)    );
  // itree = 13
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.322353,-0.0141253) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.60452,0.00951314) , 
2, 68.6021, 1, 0, 0.405316,-0.0329789) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.485294,-0.0109084) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.733871,0.0211121) , 
9, 511.138, 1, 0, 0.68038,0.0629599) , 
8, 0.91015, 1, 0, 0.5,4.57604e-05)    );
  // itree = 14
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.366726,-0.01103) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.657795,0.0135609) , 
2, 69.5392, 1, 0, 0.459854,-0.0143623) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.782609,0.0179011) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.9,0.0433397) , 
7, 0.993602, 1, 0, 0.84375,0.123432) , 
5, 0.982933, 1, 0, 0.5,4.74742e-05)    );
  // itree = 15
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.27,-0.023533) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.542636,0.00579595) , 
9, 699.193, 1, 0, 0.3769,-0.0543301) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.341772,-0.0195647) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.603922,0.0107768) , 
3, 328.566, 1, 0, 0.568761,0.0304454) , 
7, 0.943241, 1, 0, 0.5,6.2894e-05)    );
  // itree = 16
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.37931,-0.00870911) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.686275,0.024627) , 
3, 706.379, 1, 0, 0.405316,-0.026896) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.485294,-0.00924452) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.733871,0.017792) , 
9, 511.138, 1, 0, 0.68038,0.0513661) , 
8, 0.91015, 1, 0, 0.5,4.39077e-05)    );
  // itree = 17
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.366726,-0.00920649) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.657795,0.011194) , 
2, 69.5392, 1, 0, 0.459854,-0.0120374) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.782609,0.014587) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.9,0.039605) , 
7, 0.993602, 1, 0, 0.84375,0.103547) , 
5, 0.982933, 1, 0, 0.5,4.97977e-05)    );
  // itree = 18
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.27,-0.0203316) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.542636,0.00498023) , 
9, 699.193, 1, 0, 0.3769,-0.0458301) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.341772,-0.0167308) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.603922,0.00922419) , 
3, 328.566, 1, 0, 0.568761,0.0256958) , 
7, 0.943241, 1, 0, 0.5,6.17812e-05)    );
  // itree = 19
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.3,-0.0234303) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.40458,-0.00623883) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.613187,0.00944931) , 
7, 0.959849, 1, 0, 0.516509,0.00899477) , 
8, 0.822944, 1, 0, 0.5,4.50846e-05)    );
  // itree = 20
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.366726,-0.00789729) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.657795,0.00962329) , 
2, 69.5392, 1, 0, 0.459854,-0.0101885) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.782609,0.0119416) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.9,0.0362908) , 
7, 0.993602, 1, 0, 0.84375,0.0876082) , 
5, 0.982933, 1, 0, 0.5,3.86026e-05)    );
  // itree = 21
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.3,-0.0210018) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.40458,-0.00538549) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.613187,0.00829446) , 
7, 0.959849, 1, 0, 0.516509,0.00797245) , 
8, 0.822944, 1, 0, 0.5,4.89411e-05)    );
  // itree = 22
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.307479,-0.010896) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.763889,0.0184119) , 
8, 0.944903, 1, 0, 0.383372,-0.0279401) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.631737,0.0142398) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.543046,-0.0133821) , 
9, 891.866, 1, 0, 0.604124,0.0250243) , 
9, 617.741, 1, 0, 0.5,4.21848e-05)    );
  // itree = 23
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.223529,-0.02382) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.44898,0.00157298) , 
7, 0.969669, 1, 0, 0.30597,-0.0615923) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.41866,-0.00465097) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.663934,0.0102499) , 
4, 339.862, 1, 0, 0.533163,0.0105769) , 
3, 331.502, 1, 0, 0.5,4.2393e-05)    );
  // itree = 24
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.3,-0.0187824) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.40458,-0.00460794) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.613187,0.00721288) , 
7, 0.959849, 1, 0, 0.516509,0.0070135) , 
8, 0.822944, 1, 0, 0.5,3.38931e-05)    );
  // itree = 25
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.366726,-0.00637801) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.657795,0.00785411) , 
2, 69.5392, 1, 0, 0.459854,-0.0079691) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.87234,0.029925) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.816327,0.00970367) , 
1, 86.6532, 1, 0, 0.84375,0.0685112) , 
5, 0.982933, 1, 0, 0.5,2.88429e-05)    );
  // itree = 26
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.217391,-0.029397) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.352273,-0.00434022) , 
2, 40.0964, 1, 0, 0.30597,-0.0540946) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.526059,0.00567247) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.558824,-0.010436) , 
9, 869.361, 1, 0, 0.533163,0.0092868) , 
3, 331.502, 1, 0, 0.5,3.5051e-05)    );
  // itree = 27
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.48886,0.00221613) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.481481,-0.0247366) , 
9, 887.522, 1, 0, 0.487945,-0.00538535) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.723404,0.0218149) , 
4, 626.721, 1, 0, 0.5,2.72113e-05)    );
  // itree = 28
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.447289,-0.000497136) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.490909,-0.0278446) , 
4, 393.013, 1, 0, 0.450626,-0.0116019) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.771739,0.0266535) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.598131,-0.00451754) , 
9, 911.297, 1, 0, 0.678392,0.0420678) , 
3, 578.573, 1, 0, 0.5,3.23481e-05)    );
  // itree = 29
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.48886,0.00192409) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.481481,-0.0217503) , 
9, 887.522, 1, 0, 0.487945,-0.00494155) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.723404,0.0202617) , 
4, 626.721, 1, 0, 0.5,4.26726e-05)    );
  // itree = 30
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.349593,-0.00953055) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.578125,0.0178505) , 
0, 131.73, 1, 0, 0.383372,-0.0228087) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.631737,0.0113926) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.543046,-0.0099529) , 
9, 891.866, 1, 0, 0.604124,0.0204471) , 
9, 617.741, 1, 0, 0.5,4.43288e-05)    );
  // itree = 31
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.27,-0.0150427) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.542636,0.00544009) , 
9, 699.193, 1, 0, 0.3769,-0.0287879) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.341772,-0.0134249) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.603922,0.0063459) , 
3, 328.566, 1, 0, 0.568761,0.0161429) , 
7, 0.943241, 1, 0, 0.5,4.02557e-05)    );
  // itree = 32
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.3,-0.0163163) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.40458,-0.00397392) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.613187,0.00623137) , 
7, 0.959849, 1, 0, 0.516509,0.00599003) , 
8, 0.822944, 1, 0, 0.5,2.9454e-05)    );
  // itree = 33
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.283582,-0.0178742) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.495025,0.000347088) , 
8, 0.822093, 1, 0, 0.47876,-0.00459969) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.893617,0.0277867) , 
8, 0.979915, 1, 0, 0.5,2.51242e-05)    );
  // itree = 34
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.487562,0.00112283) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.492537,-0.0258487) , 
1, 139.539, 1, 0, 0.487945,-0.00457906) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.723404,0.0189072) , 
4, 626.721, 1, 0, 0.5,2.7397e-05)    );
  // itree = 35
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.447289,-0.000439151) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.490909,-0.0250887) , 
4, 393.013, 1, 0, 0.450626,-0.0104308) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.771739,0.0237991) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.598131,-0.00342221) , 
9, 911.297, 1, 0, 0.678392,0.0378307) , 
3, 578.573, 1, 0, 0.5,3.11504e-05)    );
  // itree = 36
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.487562,0.00102787) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.492537,-0.0235209) , 
1, 139.539, 1, 0, 0.487945,-0.00419118) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.723404,0.0175106) , 
4, 626.721, 1, 0, 0.5,3.88306e-05)    );
  // itree = 37
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.361111,-0.00664154) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.54386,0.0147678) , 
3, 431.013, 1, 0, 0.382413,-0.0174351) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.665541,0.0102898) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.56391,-0.00783158) , 
9, 898.174, 1, 0, 0.634033,0.0199594) , 
3, 455.037, 1, 0, 0.5,4.0132e-05)    );
  // itree = 38
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.45107,-0.00018857) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.446154,-0.0225386) , 
9, 822.012, 1, 0, 0.450626,-0.00972576) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.771739,0.021589) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.598131,-0.00238581) , 
9, 911.297, 1, 0, 0.678392,0.0353133) , 
3, 578.573, 1, 0, 0.5,3.76126e-05)    );
  // itree = 39
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.757576,0.0187244) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.37251,-0.00669244) , 
6, 0.000342846, 1, 0, 0.43594,-0.0131582) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.721154,0.0268762) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.57277,-0.00440872) , 
9, 810.71, 1, 0, 0.621451,0.0250663) , 
9, 724.344, 1, 0, 0.5,4.13062e-05)    );
  // itree = 40
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.487562,0.000900375) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.492537,-0.021731) , 
1, 139.539, 1, 0, 0.487945,-0.00411334) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.723404,0.01725) , 
4, 626.721, 1, 0, 0.5,4.65918e-05)    );
  // itree = 41
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.389908,0.00180756) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.351351,-0.0187055) , 
7, 0.921338, 1, 0, 0.3769,-0.0230363) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.341772,-0.0120882) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.603922,0.00533672) , 
3, 328.566, 1, 0, 0.568761,0.0129397) , 
7, 0.943241, 1, 0, 0.5,4.63517e-05)    );
  // itree = 42
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.469529,0.00117164) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.528736,-0.0227613) , 
4, 413.94, 1, 0, 0.475896,-0.00623287) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.584906,-0.00043597) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.767857,0.0222182) , 
7, 0.969139, 1, 0, 0.678899,0.0465903) , 
0, 226.391, 1, 0, 0.5,3.91626e-05)    );
  // itree = 43
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.447289,-0.000396641) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.490909,-0.0209477) , 
4, 393.013, 1, 0, 0.450626,-0.0088595) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.771739,0.0201474) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.598131,-0.00229053) , 
9, 911.297, 1, 0, 0.678392,0.0322129) , 
3, 578.573, 1, 0, 0.5,4.39985e-05)    );
  // itree = 44
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.410839,-0.00405341) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.608696,0.0049847) , 
9, 724.344, 1, 0, 0.47876,-0.00378382) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.893617,0.0245344) , 
8, 0.979915, 1, 0, 0.5,4.71433e-05)    );
  // itree = 45
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.32,-0.0122169) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.479167,0.0201482) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.518239,-5.18853e-05) , 
5, 0.907234, 1, 0, 0.516014,0.00479765) , 
5, 0.897426, 1, 0, 0.5,4.80141e-05)    );
  // itree = 46
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.3,-0.012179) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.40458,-0.00323295) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.613187,0.00491459) , 
7, 0.959849, 1, 0, 0.516509,0.00438053) , 
8, 0.822944, 1, 0, 0.5,4.02547e-05)    );
  // itree = 47
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.217391,-0.0283682) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.50303,0.00066731) , 
2, 36.2278, 1, 0, 0.487945,-0.00342944) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.723404,0.0146752) , 
4, 626.721, 1, 0, 0.5,3.53389e-05)    );
  // itree = 48
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.354369,-0.0049394) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.590414,0.00281683) , 
9, 617.741, 1, 0, 0.47876,-0.00333931) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.893617,0.0224187) , 
8, 0.979915, 1, 0, 0.5,2.78015e-05)    );
  // itree = 49
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.356223,-0.000975454) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.520833,0.0336442) , 
1, 69.2059, 1, 0, 0.384342,0.0215864) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.245283,-0.0411967) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.578767,0.00117992) , 
3, 374.33, 1, 0, 0.55102,-0.00948092) , 
4, 258.448, 1, 0, 0.5,2.88009e-05)    );
  // itree = 50
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.355392,-0.00565197) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.633766,0.00843357) , 
3, 426.451, 1, 0, 0.490542,0.00556164) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.396226,-0.0298358) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.680556,0.00894661) , 
3, 687.95, 1, 0, 0.56,-0.0351968) , 
9, 937.55, 1, 0, 0.5,1.17476e-05)    );
  // itree = 51
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.356223,-0.000340562) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.520833,0.0301462) , 
1, 69.2059, 1, 0, 0.384342,0.0214807) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.245283,-0.0371438) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.578767,0.000779285) , 
3, 374.33, 1, 0, 0.55102,-0.00945709) , 
4, 258.448, 1, 0, 0.5,1.29879e-05)    );
  // itree = 52
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.283582,-0.0220246) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.404959,0.00220217) , 
6, 0.00458725, 1, 0, 0.361702,-0.0275521) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.490566,0.0187394) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.539143,0.000254265) , 
8, 0.848065, 1, 0, 0.535616,0.00709546) , 
8, 0.840386, 1, 0, 0.5,-1.12051e-07)    );
  // itree = 53
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.501992,0.00238838) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.554622,-0.00897722) , 
9, 937.55, 1, 0, 0.509174,0.00317639) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.326087,-0.0135314) , 
6, 0.00589104, 1, 0, 0.5,-5.00443e-06)    );
  // itree = 54
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.366726,-0.00440783) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.657795,0.00591865) , 
2, 69.5392, 1, 0, 0.459854,-0.00465332) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.87234,0.0246712) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.816327,0.000693658) , 
1, 86.6532, 1, 0, 0.84375,0.0397998) , 
5, 0.982933, 1, 0, 0.5,-4.62472e-06)    );
  // itree = 55
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.356223,-0.000231065) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.520833,0.0268492) , 
1, 69.2059, 1, 0, 0.384342,0.0196072) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.245283,-0.0341736) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.578767,0.00066967) , 
3, 374.33, 1, 0, 0.55102,-0.00864722) , 
4, 258.448, 1, 0, 0.5,1.45049e-06)    );
  // itree = 56
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.387255,0.00341397) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.36,-0.0156332) , 
7, 0.915984, 1, 0, 0.3769,-0.0171094) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.560606,0.00421629) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.639344,-0.0153732) , 
2, 98.3329, 1, 0, 0.568761,0.00954351) , 
7, 0.943241, 1, 0, 0.5,-8.55939e-06)    );
  // itree = 57
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.487562,0.00101739) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.492537,-0.0197769) , 
1, 139.539, 1, 0, 0.487945,-0.00300798) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.723404,0.0128472) , 
4, 626.721, 1, 0, 0.5,-7.2509e-06)    );
  // itree = 58
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.342466,0.00401281) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.262295,-0.0220965) , 
1, 55.1647, 1, 0, 0.30597,-0.0316512) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.41866,-0.00387634) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.663934,0.00706835) , 
4, 339.862, 1, 0, 0.533163,0.00540561) , 
3, 331.502, 1, 0, 0.5,-3.55679e-06)    );
  // itree = 59
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.32,-0.0100874) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.479167,0.0187456) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.518239,-0.000201844) , 
5, 0.907234, 1, 0, 0.516014,0.00380692) , 
5, 0.897426, 1, 0, 0.5,-5.52426e-06)    );
  // itree = 60
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.436153,-0.00214237) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.710526,0.02112) , 
9, 724.957, 1, 0, 0.479777,0.00670774) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.4,-0.0246822) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.654412,0.00379201) , 
2, 67.8236, 1, 0, 0.572139,-0.0239604) , 
9, 830.947, 1, 0, 0.5,-7.1725e-06)    );
  // itree = 61
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.245614,-0.0171329) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.419643,0.0100031) , 
3, 296.981, 1, 0, 0.384342,0.0194248) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.245283,-0.0310267) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.578767,0.000374091) , 
3, 374.33, 1, 0, 0.55102,-0.00857168) , 
4, 258.448, 1, 0, 0.5,-1.94928e-06)    );
  // itree = 62
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.283582,-0.0125085) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.495025,0.000262835) , 
8, 0.822093, 1, 0, 0.47876,-0.00297254) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.893617,0.0204803) , 
8, 0.979915, 1, 0, 0.5,-1.25463e-05)    );
  // itree = 63
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.37931,-0.00386784) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.686275,0.0171339) , 
3, 706.379, 1, 0, 0.405316,-0.00870192) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.688889,0.00748667) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.630435,-0.0133964) , 
9, 937.55, 1, 0, 0.68038,0.0165519) , 
8, 0.91015, 1, 0, 0.5,-8.89969e-06)    );
  // itree = 64
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.344498,-0.00147091) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.5,0.0200148) , 
4, 240.856, 1, 0, 0.384342,0.0179162) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.245283,-0.028596) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.578767,0.000293919) , 
3, 374.33, 1, 0, 0.55102,-0.00790938) , 
4, 258.448, 1, 0, 0.5,-4.17694e-06)    );
  // itree = 65
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.404255,0.0126097) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.477301,-0.00175124) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.910714,0.0255369) , 
5, 0.988147, 1, 0, 0.505166,-0.00280773) , 
5, 0.889652, 1, 0, 0.5,-1.14188e-05)    );
  // itree = 66
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.436153,-0.00188317) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.710526,0.019332) , 
9, 724.957, 1, 0, 0.479777,0.00628646) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.4,-0.0225161) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.654412,0.00321452) , 
2, 67.8236, 1, 0, 0.572139,-0.022444) , 
9, 830.947, 1, 0, 0.5,-4.18373e-06)    );
  // itree = 67
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.309859,-0.0120103) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.526841,0.00177144) , 
5, 0.897426, 1, 0, 0.509174,0.00269055) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.326087,-0.0116489) , 
6, 0.00589104, 1, 0, 0.5,-1.37552e-07)    );
  // itree = 68
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.404255,0.0126529) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.379421,-0.00585524) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.575,0.00232888) , 
7, 0.948802, 1, 0, 0.505166,-0.00280099) , 
5, 0.889652, 1, 0, 0.5,-1.93603e-06)    );
  // itree = 69
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.407986,-0.00199686) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.75,0.0256595) , 
4, 345.816, 1, 0, 0.453313,0.00693322) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.450549,-0.0205012) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.717791,0.00638552) , 
5, 0.936446, 1, 0, 0.622047,-0.0181365) , 
4, 381.206, 1, 0, 0.5,-3.29215e-06)    );
  // itree = 70
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.245614,-0.0153167) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.419643,0.00895602) , 
3, 296.981, 1, 0, 0.384342,0.0175811) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.35,-0.0145577) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.607646,0.00163347) , 
9, 571.527, 1, 0, 0.55102,-0.00774728) , 
4, 258.448, 1, 0, 0.5,5.73788e-06)    );
  // itree = 71
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.404255,0.0118192) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.477301,-0.00158743) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.910714,0.0234375) , 
5, 0.988147, 1, 0, 0.505166,-0.00263116) , 
5, 0.889652, 1, 0, 0.5,-1.16227e-06)    );
  // itree = 72
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.364679,-0.00373267) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.644258,0.00671386) , 
4, 306.234, 1, 0, 0.490542,0.00434952) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.396226,-0.0239448) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.680556,0.00730867) , 
3, 687.95, 1, 0, 0.56,-0.0275645) , 
9, 937.55, 1, 0, 0.5,3.93427e-06)    );
  // itree = 73
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.356223,7.09447e-05) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.520833,0.0224816) , 
1, 69.2059, 1, 0, 0.384342,0.0175014) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.245283,-0.0252551) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.578767,1.04044e-05) , 
3, 374.33, 1, 0, 0.55102,-0.00771359) , 
4, 258.448, 1, 0, 0.5,4.72424e-06)    );
  // itree = 74
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.401728,-0.00123642) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.64,0.0242793) , 
1, 83.4776, 1, 0, 0.434944,0.00928208) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.320755,-0.0256121) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.636086,0.000431616) , 
3, 444.955, 1, 0, 0.592105,-0.0131459) , 
1, 88.9612, 1, 0, 0.5,-1.85171e-06)    );
  // itree = 75
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.407986,-0.00149934) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.75,0.022851) , 
4, 345.816, 1, 0, 0.453313,0.00698922) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.450549,-0.0189358) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.717791,0.00535909) , 
5, 0.936446, 1, 0, 0.622047,-0.0182817) , 
4, 381.206, 1, 0, 0.5,-2.94629e-06)    );
  // itree = 76
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.264286,-0.00515368) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.503546,0.0127451) , 
7, 0.959356, 1, 0, 0.384342,0.0167851) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.35,-0.0125455) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.607646,0.00115076) , 
9, 571.527, 1, 0, 0.55102,-0.00739804) , 
4, 258.448, 1, 0, 0.5,4.42412e-06)    );
  // itree = 77
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.404255,0.0116759) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.477301,-0.00148797) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.910714,0.0217622) , 
5, 0.988147, 1, 0, 0.505166,-0.00258778) , 
5, 0.889652, 1, 0, 0.5,2.45837e-07)    );
  // itree = 78
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.469529,0.00162688) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.528736,-0.0215023) , 
4, 413.94, 1, 0, 0.475896,-0.00386319) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.584906,-0.00230544) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.767857,0.01692) , 
7, 0.969139, 1, 0, 0.678899,0.0287092) , 
0, 226.391, 1, 0, 0.5,4.33527e-06)    );
  // itree = 79
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.350877,0.0097356) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.272727,-0.0184471) , 
9, 413.355, 1, 0, 0.30597,-0.0254111) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.474012,0.00417505) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.627063,-0.0046631) , 
7, 0.975506, 1, 0, 0.533163,0.00435479) , 
3, 331.502, 1, 0, 0.5,9.88176e-06)    );
  // itree = 80
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.301075,-0.0122345) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.53125,0.0308558) , 
2, 38.8605, 1, 0, 0.394904,0.0229829) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.404762,-0.00584369) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.665689,0.00459632) , 
4, 344.229, 1, 0, 0.521682,-0.00473549) , 
2, 42.1059, 1, 0, 0.5,5.01191e-06)    );
  // itree = 81
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.436153,-0.00154263) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.710526,0.017023) , 
9, 724.957, 1, 0, 0.479777,0.00575574) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.4,-0.0211674) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.654412,0.00307655) , 
2, 67.8236, 1, 0, 0.572139,-0.0205443) , 
9, 830.947, 1, 0, 0.5,-2.75913e-06)    );
  // itree = 82
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.264286,-0.00461462) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.503546,0.0121214) , 
7, 0.959356, 1, 0, 0.384342,0.0165678) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.245283,-0.0219875) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.578767,-0.000186956) , 
3, 374.33, 1, 0, 0.55102,-0.00730822) , 
4, 258.448, 1, 0, 0.5,2.32835e-07)    );
  // itree = 83
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.407986,-0.00113511) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.75,0.020305) , 
4, 345.816, 1, 0, 0.453313,0.00675464) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.450549,-0.0172614) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.717791,0.00451421) , 
5, 0.936446, 1, 0, 0.622047,-0.0176747) , 
4, 381.206, 1, 0, 0.5,-4.6759e-06)    );
  // itree = 84
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.346939,-0.0037785) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.44898,0.0182697) , 
6, 0.00334507, 1, 0, 0.397959,0.0313879) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.363636,-0.0071207) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.574394,0.00177027) , 
7, 0.946008, 1, 0, 0.512195,-0.00374964) , 
7, 0.886777, 1, 0, 0.5,1.42972e-06)    );
  // itree = 85
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.401728,-0.000949233) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.64,0.0220343) , 
1, 83.4776, 1, 0, 0.434944,0.00887357) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.605536,-0.00800824) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.549451,0.0109462) , 
6, 0.00346561, 1, 0, 0.592105,-0.0125666) , 
1, 88.9612, 1, 0, 0.5,-1.46065e-06)    );
  // itree = 86
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.309859,-0.0104475) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.526841,0.00159469) , 
5, 0.897426, 1, 0, 0.509174,0.00248639) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.326087,-0.0109176) , 
6, 0.00589104, 1, 0, 0.5,1.96694e-06)    );
  // itree = 87
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.404255,0.0120885) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.350318,-0.00739739) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.539216,0.000923593) , 
8, 0.840636, 1, 0, 0.505166,-0.00266874) , 
5, 0.889652, 1, 0, 0.5,2.93397e-07)    );
  // itree = 88
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.333333,-0.00992651) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.465517,0.0223762) , 
6, 0.00274624, 1, 0, 0.401786,0.0287979) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.41791,0.00744007) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.532738,-0.00264993) , 
2, 42.1059, 1, 0, 0.513648,-0.00400317) , 
5, 0.905199, 1, 0, 0.5,-1.29837e-06)    );
  // itree = 89
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.404255,0.0107403) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.360656,-0.00519051) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.583039,0.00186026) , 
0, 103.243, 1, 0, 0.505166,-0.00239039) , 
5, 0.889652, 1, 0, 0.5,-5.18834e-06)    );
  // itree = 90
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.245614,-0.0138432) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.419643,0.00824135) , 
3, 296.981, 1, 0, 0.384342,0.016461) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.494819,0.00242183) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.63745,-0.00926753) , 
7, 0.975506, 1, 0, 0.55102,-0.00727004) , 
4, 258.448, 1, 0, 0.5,-5.97613e-06)    );
  // itree = 91
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.32,-0.00865954) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.479167,0.0174052) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.518239,-0.000266658) , 
5, 0.907234, 1, 0, 0.516014,0.00319009) , 
5, 0.897426, 1, 0, 0.5,-6.30052e-06)    );
  // itree = 92
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.469529,0.00143297) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.528736,-0.0192982) , 
4, 413.94, 1, 0, 0.475896,-0.00363115) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.584906,-0.00212662) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.767857,0.0159406) , 
7, 0.969139, 1, 0, 0.678899,0.0268891) , 
0, 226.391, 1, 0, 0.5,-7.2948e-06)    );
  // itree = 93
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.404255,0.0102754) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.360656,-0.00510511) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.583039,0.00184821) , 
0, 103.243, 1, 0, 0.505166,-0.00229089) , 
5, 0.889652, 1, 0, 0.5,-1.72209e-06)    );
  // itree = 94
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.356223,0.000131239) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.520833,0.0197885) , 
1, 69.2059, 1, 0, 0.384342,0.0156811) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.48072,-0.00599676) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.66129,0.0049836) , 
3, 543.944, 1, 0, 0.55102,-0.0069214) , 
4, 258.448, 1, 0, 0.5,-2.77615e-06)    );
  // itree = 95
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.32,-0.0083632) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.434783,0.0140135) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.523256,-0.000461517) , 
7, 0.899696, 1, 0, 0.516014,0.00307678) , 
5, 0.897426, 1, 0, 0.5,-3.24398e-06)    );
  // itree = 96
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.436153,-0.00141584) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.710526,0.0156228) , 
9, 724.957, 1, 0, 0.479777,0.00517826) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.4,-0.0196382) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.654412,0.00303301) , 
2, 67.8236, 1, 0, 0.572139,-0.0184937) , 
9, 830.947, 1, 0, 0.5,-4.82471e-06)    );
  // itree = 97
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.404255,0.0101903) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.477301,-0.0013867) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.910714,0.0212646) , 
5, 0.988147, 1, 0, 0.505166,-0.00226639) , 
5, 0.889652, 1, 0, 0.5,-2.07762e-06)    );
  // itree = 98
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.32,-0.00805797) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.479167,0.015047) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.518239,-0.00018198) , 
5, 0.907234, 1, 0, 0.516014,0.00295808) , 
5, 0.897426, 1, 0, 0.5,2.1522e-06)    );
  // itree = 99
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.264286,-0.00448411) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.503546,0.0111288) , 
7, 0.959356, 1, 0, 0.384342,0.0146836) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.494819,0.00227896) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.63745,-0.00846903) , 
7, 0.975506, 1, 0, 0.55102,-0.00647633) , 
4, 258.448, 1, 0, 0.5,7.17861e-07)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
